<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS应用加固]]></title>
    <url>%2F2018%2F08%2F17%2FiOS%E5%BA%94%E7%94%A8%E5%8A%A0%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[完整性校验通过检测SignerIdentity判断是Mach-O文件否被篡改 原理是：SignerIdentity的值在info.plist中是不存在的，开发者不会加上去，苹果也不会，只是当ipa包被反编译后篡改文件再次打包，需要伪造SignerIdentity。1234567NSBundle *bundle = [NSBundle mainBundle];NSDictionary *info = [bundle infoDictionary];if ([info objectForKey:@&quot;SignerIdentity&quot;] != nil)&#123; return YES;&#125;return NO; 参考：https://www.jianshu.com/p/91aa49c45677 越狱检测参照念茜大神的方法：iOS安全攻防（二十）：越狱检测的攻与防,很详细的讲述了检测的办法，不过经过测试，发现有的方法在未越狱的设备上也会检测成越狱，可以在使用的时候过滤掉这些方法。 双击home键后app缩略视图模糊处理有时候双击home键，app展示启动app记录，会有可能暴露敏感信息，可以在app退至后台时做一个模糊处理，然后进入前台后移除模糊效果。实现如下： 12345678910111213141516171819202122232425262728@interface AppDelegate ()@property(nonatomic,strong)UIVisualEffectView *effectView;@end@implementation AppDelegate- (void)applicationDidEnterBackground:(UIApplication *)application&#123; [self.window addSubview:self.effectView];&#125;- (void)applicationWillEnterForeground:(UIApplication *)application&#123; [self.effectView removeFromSuperview];&#125;-(UIVisualEffectView *)effectView&#123; if (!_effectView) &#123; UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; _effectView = [[UIVisualEffectView alloc] initWithEffect:effect]; _effectView.frame = self.window.bounds; &#125; return _effectView;&#125;...@end 方法名混淆也是参照念茜大神的方法：iOS安全攻防（二十三）：Objective-C代码混淆. 明文字符串混淆参考这篇文章：iOS字符串硬编码混淆. 可能作者的步骤描述的不是很清楚，我在这里简单描述一下：1.在项目的.pch文件中，添加如下代码 123456789101112#include &quot;GolobalCFile.h&quot;//字符串混淆加密 和 解密的宏开关//#define ggh_confusion#ifdef ggh_confusion#define confusion_NSSTRING(string) [NSString stringWithUTF8String:decryptConstString(string)]#define confusion_CSTRING(string) decryptConstString(string)#else#define confusion_NSSTRING(string) @string#define confusion_CSTRING(string) string#endif 其中decryptConstString定义在c文件GolobalCFile中12345678910111213/* * 字符串混淆解密函数，将char[] 形式字符数组和 aa异或运算揭秘 * 如果没有经过混淆，请关闭宏开关 */extern char* decryptConstString(char* string)&#123; char* origin_string = string; while(*string) &#123; *string ^= 0xAA; string++; &#125; return origin_string;&#125; 2.打开终端Terminal，cd到你的工程根目录；3.执行如下混淆脚本（执行之前将脚本里面的工程名字改为你的工程名字）：1python .../confusion.py 将如下脚本写在一个文件里confusion.py。在终端执行即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env python# encoding=utf8# -*- coding: utf-8 -*-# 本脚本用于对源代码中的字符串进行加密# 替换所有字符串常量为加密的char数组，形式((char[])&#123;1, 2, 3, 0&#125;)import importlibimport osimport reimport sys# 替换字符串为((char[])&#123;1, 2, 3, 0&#125;)的形式，同时让每个字节与0xAA异或进行加密def replace(match): string = match.group(2) + &apos;\x00&apos; replaced_string = &apos;((char []) &#123;&apos; + &apos;, &apos;.join([&quot;%i&quot; % ((ord© ^ 0xAA) if c != &apos;\0&apos; else 0) for c in list(string)]) + &apos;&#125;)&apos; return match.group(1) + replaced_string + match.group(3)# 修改源代码，加入字符串加密的函数def obfuscate(file): with open(file, &apos;r&apos;) as f: code = f.read() f.close() code = re.sub(r&apos;(confusion_NSSTRING\(|confusion_CSTRING\()&quot;(.*?)&quot;(\))&apos;, replace, code) code = re.sub(r&apos;//#define ggh_confusion&apos;, &apos;#define ggh_confusion&apos;, code) with open(file, &apos;w&apos;) as f: f.write(code) f.close()#读取源码路径下的所有.h和.m 文件def openSrcFile(path): print(&quot;开始处理路径： &quot;+ path +&quot; 下的所有.h和.m文件&quot;) # this folder is custom for parent,dirnames,filenames in os.walk(path): #case 1: # for dirname in dirnames: # print((&quot; parent folder is:&quot; + parent).encode(&apos;utf-8&apos;)) # print((&quot; dirname is:&quot; + dirname).encode(&apos;utf-8&apos;)) #case 2 for filename in filenames: extendedName = os.path.splitext(os.path.join(parent,filename)) if (extendedName[1] == &apos;.h&apos; or extendedName[1] == &apos;.m&apos;): print(&quot;处理源代码文件: &quot;+ os.path.join(parent,filename)) obfuscate(os.path.join(parent,filename))#源码路径srcPath = &apos;../StringDecodeDemo&apos;if __name__ == &apos;__main__&apos;: print(&quot;本脚本用于对源代码中被标记的字符串进行加密&quot;) if len(srcPath) &gt; 0: openSrcFile(srcPath) else: print(&quot;请输入正确的源代码路径&quot;) sys.exit() 执行完成后查看你的代码，会发现用confusion_NSSTRING和confusion_CSTRING 写的明文字符串都被编码。这样就达到了混淆的效果。 4.由于代码被混淆不利于以后项目迭代，所以需要解码。方法同编码，在终端执行如下脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env python# encoding=utf8# -*- coding: utf-8 -*-# 本脚本用于对源代码中的字符串进行解密# 替换所有加密的char数组为字符串常量，&quot;&quot;import importlibimport osimport reimport sys# 替换((char[])&#123;1, 2, 3, 0&#125;)的形式为字符串，同时让每个数组值与0xAA异或进行解密def replace(match): string = match.group(2) decodeConfusion_string = &quot;&quot; for numberStr in list(string.split(&apos;,&apos;)): if int(numberStr) != 0: decodeConfusion_string = decodeConfusion_string + &quot;%c&quot; % (int(numberStr) ^ 0xAA)# replaced_string = &apos;\&quot;&apos; + &quot;&quot;.join([&quot;%c&quot; % ((int© ^ 0xAA) if int© != 0 else &apos;\0&apos;) for c in string.split(&apos;,&apos;)]) + &apos;\&quot;&apos; replaced_string = &apos;\&quot;&apos; + decodeConfusion_string + &apos;\&quot;&apos; print(&quot;replaced_string = &quot; + replaced_string) return match.group(1) + replaced_string + match.group(3)# 修改源代码，加入字符串加密的函数def obfuscate(file): with open(file, &apos;r&apos;) as f: code = f.read() f.close() code = re.sub(r&apos;(confusion_NSSTRING\(|confusion_CSTRING\()\(\(char \[\]\) \&#123;(.*?)\&#125;\)(\))&apos;, replace, code) code = re.sub(r&apos;[/]*#define ggh_confusion&apos;, &apos;//#define ggh_confusion&apos;, code) with open(file, &apos;w&apos;) as f: f.write(code) f.close()#读取源码路径下的所有.h和.m 文件def openSrcFile(path): print(&quot;开始处理路径： &quot;+ path +&quot; 下的所有.h和.m文件&quot;) # this folder is custom for parent,dirnames,filenames in os.walk(path): #case 1: # for dirname in dirnames: # print((&quot; parent folder is:&quot; + parent).encode(&apos;utf-8&apos;)) # print((&quot; dirname is:&quot; + dirname).encode(&apos;utf-8&apos;)) #case 2 for filename in filenames: extendedName = os.path.splitext(os.path.join(parent,filename)) #读取所有.h和.m 的源文件 if (extendedName[1] == &apos;.h&apos; or extendedName[1] == &apos;.m&apos;): print(&quot;处理代码文件:&quot;+ os.path.join(parent,filename)) obfuscate(os.path.join(parent,filename))#源码路径srcPath = &apos;../StringDecodeDemo&apos;if __name__ == &apos;__main__&apos;: print(&quot;字符串解混淆脚本，将被标记过的char数组转为字符串，并和0xAA异或。还原代码&quot;) if len(srcPath) &gt; 0: openSrcFile(srcPath) else: print(&quot;请输入正确的源代码路径！&quot;) sys.exit() 即可解码明文。 为了不那么麻烦，可以打包前将工程拷贝一份，这样就可以只需要编码，不用解码。 以上脚本和代码均在文末Demo中。 反编译 在混淆了函数名以后，当然要检验一下成果了，这里就需要反编译我们的app了，有个很方便的工具Class-dump,这里有篇文章详细的描述了安装和使用方法：Objective-C Class-dump 安装和使用方法(原创). 另外还有一个反编译、反汇编和调试神器：Hopper。可以查看源码。 疑问1.执行脚本文件时报如下错误1confusion.py: Permission denied 解决方法：1、打开终端。2、cd到目标文件夹。3、输入 chmod 755 你的文件名.sh。 Demo本文demo：iOS_CodeEncrypt]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化打包工具集Fastlnae]]></title>
    <url>%2F2018%2F08%2F13%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E9%9B%86Fastlane%2F</url>
    <content type="text"><![CDATA[什么是Fastlane Fastlane是一套使用Ruby写的自动化工具集，旨在简化Android和iOS的部署过程，自动化你的工作流。它可以简化一些乏味、单调、重复的工作，像截图、代码签名以及发布App. 如何安装Fastlane 安装xcode命令行工具1xcode-select --install 如果没有安装，会弹出对话框，点击安装; 如果已经安装,就会提示 xcode-select: error: command line tools are already installed, use “Software Update” to install updates。 安装Fastlane 使用下面的命令1sudo gem install fastlane -NV 或是1brew cask install fastlane 来安装Fastlane。 安装完成后，可以执行下面命令，检查是否安装好。1fastlane --version 初始化Fastlane cd到你的项目目录执行1fastlane init 过一会会出现如下提示，让你选择一个选项： 我这里希望打包上传到app store，所以选择了3. 如果你的工程是用cocoapods的那么可能会提示让你勾选工程的Scheme，步骤就是打开你的xcode，点击Manage Schemes，在一堆三方库中找到你的项目Scheme，在后面的多选框中进行勾选，然后rm -rf fastlane文件夹，重新fastlane init一下就不会报错了。 接着会提示你输入开发者账号和密码。 [20:48:55]: Please enter your Apple ID developer credentials[20:48:55]: Apple ID Username: 登录成功后会提示你是否需要下载你的App的metadata。点y等待就可以。 初始化成功以后，就会生成一个如下图所示的fastlane文件夹： 其中metadata和screenshots分别对应App元数据和商店应用截图。 AppfileAppfile用来存放app_identifier，apple_id和team_id。 它的格式是这样的： 12345app_identifier &quot;com.xxx.xxx&quot; # app的bundle identifierapple_id &quot;xxx@xxx.com&quot; # 你的Apple ID team_id &quot;XXXXXXXXXX&quot; # Team ID··· 你也可以为每个lane(后面会讲到)提供不同的 app_identifier, apple_id 和 team_id，例如： 123456789app_identifier &quot;com.aaa.aaa&quot;apple_id &quot;aaa@aaa.com&quot;team_id &quot;AAAAAAAAAA&quot; for_lane : release do app_identifier &quot;com.bbb.bbb&quot; apple_id &quot;bbb@bbb.com&quot; team_id &quot;AAAAAAAAAA&quot;end 这里就是为Fastfile中定义的: release设置单独的信息。 DeliverfileDeliverfile中为发布的配置信息，一般情况用不到。 FastfileFastfile是我们最应该关注的文件，也是我们的工作文件。下面是我的fastfile文件中上传至app store的lane：12345678910111213141516platform :ios do#------------------------------APP STORE-----------------------------------desc &quot;Push a new release build to the App Store&quot;lane :to_appStore do#gym用来编译ipagym(clean:true,# 编译前执行 clean，可减少 ipa 文件大小 scheme: &quot;MobileChecking&quot;,#要编译的scheme名称export_method: &quot;app-store&quot;, # Xcode 9增加export_method标签silent: true, # 隐藏没有必要的信息output_directory: &quot;./fastlane/appstoreIPA&quot;, # ipa输出目录output_name:&quot;mobileChecking&quot;, #输出的ipa名称archive_path:&quot;./fastlane/appstoreIpaArchive&quot;, #archive文件导出地址 export_xcargs: &quot;-allowProvisioningUpdates&quot;) upload_to_app_storeend 其中一个lane就是一个任务，里面是一个个的action组成的工作流。 export_method：指定打包所使用的输出方式,目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id,即xcodebuild的。 如何使用Fastlane 定义完lane之后怎么执行呢？打开终端，切换到项目的根目录：执行fastlane [lane’name]就可以了。比如我的lane名称叫appStore，那么久执行如下命令：1fastlane appStore 或者采用下面的命令会更快： 1bundle exec fastlane appStore 成功之后会在相应的路径下生成ipa文件,并会自动上传至app store。 如何配置Fastfile上传到fir####安装fir使用如下命令，安装fir：1sudo gem install fir-cli 安装完成以后，登录fir：1fir login 会让你输入你的fir.im API Token,去fir网站即可获得此token。安装fir：1fastlane add_plugin firim fir上传的lane：12345678910111213141516171819#-----------------------------------FIR-------------------------------desc &quot;Push a new release build to the FIR&quot;lane :to_fir do#build_app(workspace: &quot;MobileChecking.xcworkspace&quot;, scheme: &quot;MobileChecking&quot;)#gym用来编译ipagym(clean: true, # 编译前执行 clean，可减少 ipa 文件大小 scheme: &quot;MobileChecking&quot;, # 要编译的scheme名称export_method: &quot;ad-hoc&quot;, # Xcode 9增加export_method标签silent: true, # 隐藏没有必要的信息output_directory: &quot;./fastlane/firIPA&quot;, # ipa输出目录output_name:&quot;mobileChecking&quot;, # 输出的ipa名称archive_path:&quot;./fastlane/firIpaArchive&quot;, #archive文件导出地址 export_xcargs: &quot;-allowProvisioningUpdates&quot;, ) # 上传ipa到fir.im服务器，在fir.im获取firim_api_tokenfirim(firim_api_token: &quot;451d867c8860da31e5e46062b1ecea57&quot;)end 如果你想上传到蒲公英，可以参考这篇文章：使用 fastlane 实现 iOS 持续集成（二）。 常见错误处理 FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT1234567[14:57:59]: fastlane finished with errors[!] xcodebuild -showBuildSettings timed out after 4 retries with a base timeout of 3. You can override the base timeout value with the environment variable FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT, and the number of retries with the environment variable FASTLANE_XCODEBUILD_SETTINGS_RETRIES 在遇到这个错误之后，在命令窗口运行下面代码来更新timeout时间：12#更新timeoutexport FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT=120 参考 iOS效率神器fastlane自动打包 小团队的自动化发布－Fastlane带来的全自动化部署 iOS中使用Fastlane实现自动化打包和发布 当Fastlane遇到Xcode9打包出来不一定是ipa而是坑 Fastlane的gym指令 使用Fastlane实现iOS项目自动打包 (译)iOS自动化打包发布(fastlane)]]></content>
      <categories>
        <category>工具   //在此处输入这篇文章的分类。</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[响应链之Hit-Testing]]></title>
    <url>%2F2017%2F05%2F22%2F%E5%93%8D%E5%BA%94%E9%93%BE%E4%B9%8BHit-Testing%2F</url>
    <content type="text"><![CDATA[Hit-Testing 是什么Hit-Testing 是一个决定一个点（比如一个触摸点）是否落在一个给定的物理对象上（比如绘制在屏幕上的UIView）的一个过程。 Hit-Testing 执行时机Hit-Testing是在每次手指触摸时执行的。并且是在任何视图或者手势收到UIEvent（代表触摸属于的事件）之前。 Hit-Testing 的实现实现：Hit-Testing采用深度优先的反序访问迭代算法（先访问根节点然后从高到低访（从离用户近的视图或者说是后添加的视图）问低节点）。这种遍历方法可以减少遍历迭代的次数。 结束条件：一旦找到最深的包含触摸点的后裔视图就停止遍历（注意，是最深的）。 下面举例说明： 如上图所示，视图A\B\C依次添加到视图上，比如View B的添加比A晚比C早，而自视图B.1比B.2添加的要早。 通过深度优先的反向遍历允许一旦找到第一个最深的后裔包含触摸点的视图就停止遍历，如上图所示，找到B.1后就停止，不会继续遍历A视图。 遍历算法以向UIWindow（视图层次结构的根视图）发送hitTest:withEvent:消息开始。这个方法返回的值就是包含触摸点的最前面的视图。下面流程图说明了hit-test逻辑: 下面的代码展示了原生hitTest:withEvent:可能的实现： 12345678910111213141516- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123; return nil; &#125; if ([self pointInside:point withEvent:event]) &#123; for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; CGPoint convertedPoint = [subview convertPoint:point fromView:self]; UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event]; if (hitTestView) &#123; return hitTestView; &#125; &#125; return self; &#125; return nil;&#125; hitTest:withEvent:方法首先检查视图是否允许接收触摸事件。视图允许接收触摸事件的四个条件是： 视图不是隐藏的: self.hidden == NO 视图是允许交互的: self.userInteractionEnabled == YES 视图透明度大于0.01: self.alpha &gt; 0.01 视图包含这个点: pointInside:withEvent: == YES 图2遍历顺序为：UIWindow-&gt;MainView-&gt;View C-&gt;ViewB-&gt;View B.2-&gt;View B.1. 解释一下为什么顺序是这样： 首先遍历UIWindow，然后MainView MainView 有三个子视图ABC，根据算法描述中所讲，首先遍历离用户最近的视图，所以，先遍历View C 每次遍历时需要判断接收触摸的四个条件，由于落点不在C中，所以在hitTest遍历C时返回nil，然后继续遍历View B, 然后遍历View B的两个子视图，与第2点判断条件一样，先遍历View B.2 由于落点不在B.2中，所以继续遍历B.1,由于此时满足结束条件，即接收触摸事件并且B.1没有子视图，遍历到此结束。 覆盖hitTest:withEvent:的一些用途hitTest:withEvent:可以被覆盖,那么覆盖它可以做些什么呢？ 1.增加视图的触摸区域 如上图所示，蓝色按钮太小，如果采用设置UIButton的image来放大点击区域，调整按钮坐标的代码就很不好看了，如果用覆盖hitTest:withEvent:的方法来解决这个方法，就要优雅一些，自定义UIButton,覆盖hit-testing方法，代码如下： 1234567891011121314151617- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123; return nil; &#125; CGRect touchRect = CGRectInset(self.bounds, -10, -10); if (CGRectContainsPoint(touchRect, point)) &#123; for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; CGPoint convertedPoint = [subview convertPoint:point fromView:self]; UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event]; if (hitTestView) &#123; return hitTestView; &#125; &#125; return self; &#125; return nil;&#125; 2.传递触摸事件给父视图有的时候对于一个视图忽略触摸事件并传递给下面的视图是很重要的。例如，假设一个透明的视图覆盖在应用内所有视图的最上面。覆盖层有子视图应该相应触摸事件的一些控件和按钮。但是触摸覆盖层的其他区域应该传递给覆盖层下面的视图。为了完成这个行为，覆盖层需要覆盖hitTest:withEvent:方法来返回包含触摸点的子视图中的一个，然后其他情况返回nil，包括覆盖层包含触摸点的情况： 1234567- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; UIView *hitTestView = [super hitTest:point withEvent:event]; if (hitTestView == self) &#123; hitTestView = nil; &#125; return hitTestView;&#125; 3.传递触摸事件给子视图 蓝色方框是一个图片浏览器，在蓝色方框内滑动，可以翻动图片，但是在方框之外是无法响应的，因为手指落点不在图片浏览器的bounces里面，那么如何让手指落在上图位置时，也可以滚动图片呢？方法是在图片浏览器的父视图中，重载hitTest:withEvent:方法，当触摸到图片浏览器自视图之外的视图时，返回图片浏览器即可： 1234567- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; UIView *hitTestView = [super hitTest:point withEvent:event]; if (hitTestView) &#123; hitTestView = self.scrollView; &#125; return hitTestView;&#125; 4.响应子view超出了父view的bounds事件比如自定义Tabbar中间的大按钮，点击超出Tabbar bounds的区域也需要响应，此时重载父view的hitTest: withEvent:方法，去掉点击必须在父view内的判断，然后子view就能成为 hit-test view用于响应事件了。这篇文章详细的描述了如何实现。 参考：iOS中的Hit-Testing]]></content>
      <categories>
        <category>响应链   //在此处输入这篇文章的分类。</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UITabBar 自定义中间大按钮]]></title>
    <url>%2F2017%2F05%2F22%2FUITabBar%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E5%A4%A7%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[在项目中经常会有这种需求：在tabBar的正中间放置一个大按钮，有时候会超出tabBar的可点击范围。如下图的闲鱼： 主要思路就是： 自定义UITabBarController 自定义UITabBar 在自定义的UITabBarController中用自定义的UITabBar替换掉原有的tabbar。 首先，利用KVC在自定义的UITabBarController中用自定义的UITabBar替换掉原有的tabbar： 12CustomTabBar *myTabBar = [[CustomTabBar alloc] init];[self setValue:myTabBar forKey:@&quot;tabBar&quot;]; 大按钮好解决，用一张大点的图片即可。但是你会发现点击超出tabbar顶部的部分是不能响应的。如果你知道hit-test的工作原理，就会知道为什么超出部分不能响应。响应的四个条件是： 视图不是隐藏的: self.hidden == NO 视图是允许交互的: self.userInteractionEnabled == YES 视图透明度大于0.01: self.alpha &gt; 0.01 视图包含这个点: pointInside:withEvent: == YES在这里就是由于不满足第四个条件，即点击的point没有落在父视图的bounce之内，所以无法响应。 系统的hit-test方法实现大概如下: 123456789101112131415161718192021- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123; return nil; &#125; if ([self pointInside:point withEvent:event]) &#123; for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; CGPoint convertedPoint = [subview convertPoint:point fromView:self]; UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event]; if (hitTestView) &#123; return hitTestView; &#125; &#125; &#125; return nil;&#125; 通常解决这个问题的做法是将响应区域扩大，这个我还没有研究。 不过我的思路特殊一点：在自定义的UITabBar中重写hit-test方法，将点击的point进行修改，让它落在可点击范围之内。 由于是点击的point的y坐标超出了tabbar范围，那么只要修改这个y坐标，让他落在tabbar的可点击范围内即可。 修改y坐标的代码如下所示： 12345678910111213141516171819202122232425262728293031- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123; return nil; &#125; if ([self pointInside:point withEvent:event]) &#123; return [self mmHitTest:point withEvent:event]; &#125; else &#123; CGPoint otherPoint = CGPointMake(point.x, point.y + self.effectAreaY); return [self mmHitTest:otherPoint withEvent:event]; &#125; return nil;&#125;- (UIView *)mmHitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; CGPoint convertedPoint = [subview convertPoint:point fromView:self]; UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event]; if (hitTestView) &#123; return hitTestView; &#125; &#125; return nil;&#125; 其中effectAreaY是超出tabbar的垂直距离，比如大按钮顶部超出20，那么这个值就是20，你可以根据需求进行调整。 到这里，超出tabbar区域的大按钮点击问题就得到解决了，但是我反复点了一下，发现一个小问题，就是每个tabbar的item超出部分都能点击，这是我们不想要的。 我们想要的是落点在中间按钮范围内时才去修改这个落点，所以，加一个判断即可，只要点击的point的x坐标在中间大按钮范围之内就去修改，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123; return nil; &#125; if ([self pointInside:point withEvent:event]) &#123; return [self mmHitTest:point withEvent:event]; &#125; else &#123; CGFloat tabBarItemWidth = self.bounds.size.width/self.items.count; CGFloat left = self.center.x - tabBarItemWidth/2; CGFloat right = self.center.x + tabBarItemWidth/2; if (point.x &lt; right &amp;&amp; point.x &gt; left) &#123;//当点击的point的x坐标是中间item范围内，才去修正落点 CGPoint otherPoint = CGPointMake(point.x, point.y + self.effectAreaY); return [self mmHitTest:otherPoint withEvent:event]; &#125; &#125; return nil;&#125;- (UIView *)mmHitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; CGPoint convertedPoint = [subview convertPoint:point fromView:self]; UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event]; if (hitTestView) &#123; return hitTestView; &#125; &#125; return nil;&#125; 另外，如果想调整图片和文字位置，调整tabbarItem的属性： 12[vc.tabBarItem setImageInsets:UIEdgeInsetsMake(-30, 0, 30, 0)];//修改图片偏移量，上下，左右必须为相反数，否则图片会被压缩[vc.tabBarItem setTitlePositionAdjustment:UIOffsetMake(0, -30)];//修改文字偏移量 vc是每个根控制器。 到这里，就完美的解决了自定义大按钮及其点击问题，相当简单。 总的来说要点就是： 替换系统的UITabBar 修改点击point的落点 判断什么时候才去修改落点。 最后附上Demo：HitTesting end~ 如果觉得有用，请点个赞👍，谢谢~]]></content>
      <categories>
        <category>UI   //在此处输入这篇文章的分类。</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS常用开源库]]></title>
    <url>%2F2017%2F04%2F09%2FiOS%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E5%BA%93%2F</url>
    <content type="text"><![CDATA[❋Objective-C库❋网络请求1. AFNetworking 🔥浏览器1. SVWebViewController 🔥 数据库1. FMDB 🔥2. MagicalRecord CoreData 自动布局1. Masonry 🔥图表1. ChartsTime | Date1. DateTools时间转友好化描述 富文本1. TTTAttributedLabel 🔥2. YYText 🔥动画1. JazzHands基于keyframe的UIKit动画框架（coding-iOS有用到) 2. FeSpinner多种启动画面动画效果 3. PulsingHalo涟漪动画效果 图片相关1. SDWebImage 🔥加载网络图片 2. GPUImage 🔥图像处理 3. MWPhotoBrowser 🔥浏览图片 4. CTAssetsPickerController图片选择器 5. TDImageColors检测出图片上使用最多的颜色 6. QBImagePickerstar 1400+ 7. TOCropViewController图片剪裁，旋转等 Model1. Mantlejson转model 2. YYKit 🔥颜色Color &amp; 素材1. Chameleon 🔥一个iOS的色彩框架。它运用现代化flat color将UIColor扩展地非常美观。我们还可以通过它运用自定义颜色创建调色板(OC&amp;sWIFT) 2. FontAwesomeKit 🔥Font Awesome 是一款可缩放的矢量图标字库，你可以利用CSS将Font Awesome发挥到极致，包括：大小、颜色、阴影或者其它任何支持的效果 侧边栏1. MMDrawerController2. RESideMenu侧边栏，类似QQ 3. PKRevealControllerTextField &amp; TextView1. JVFloatLabeledTextField 🔥浮动式文本输入框 2. TextFieldEffects浮动式文本输入框 3. SlackTextViewController是功能强大易用的TableView和CollectionView下的文字输入解决方案。具有文字输入框高度自适应，自动输入，复制单元格内容等诸多好用的特色 ☆6700+ 提示进度条1. MBProgressHUD 🔥�指示器(菊花，风火轮) 2. DACircularProgress环形进度条 3. CRToast 🔥状态栏弹出消息提醒 4. RKDropdownAlert顶部通知提示 5. JDStatusBarNotificationstatus bar指示条 6. M13ProgressSuite进度条☆3000,种类很多 键盘1. IQKeyboardManager解决键盘在遮挡(OC &amp; sSwift) 引导页 &amp; 启动页1. Onboard 🔥引导页(oc &amp; swift) 卡片动画1. iCarousel很炫的视图切换，cover follow 2. ZLSwipeableView卡片动画,左右滑动消失 3. TinderSimpleSwipeCards可划动卡片，左划删除，右划选中 4. CNPPopupController弹出式卡片 5. SwipeView分页滑动视图 日历1. PDTSimpleCalendar自定义日历 下拉刷新1. MJRefresh下拉刷新，上拉加载更多,国人写的，star数量很多 2. CBStoreHouseRefreshControl效果酷炫，可以自己定制 UI1. PPNumberButton一款高度可定制性商品计数按钮 2. FRDLivelyButton按钮动态变化效果UIButton 3. DZNEmptyDataSet 🔥table展示空数据视图 4. FXBlurView对视图进行模糊操作 5.ASValueTrackingSliderUISlider带popoer跟随提示 star 1500+ 分段控件1. HMSegmentedControl2. RKSwipeBetweenViewControllers交互式分段控件,类似twitter首页划动效果 3. BWTitlePagerView类似twitter分栏效果 4. SMPageControl自定义pagecontrol。比较丰富 AlertView &amp; ActionSheet1. LMAlertView自定义AlertView 2. AHKActionSheet列表式的action sheet 3. MMPopupView弹出框，alertview ，action sheet，date picker，验证码输入框 角标1. JSBadgeView角标 2. RKNotificationHub角标 3. BBBadgeBarButtonItem角标 TableView1. RETableViewManager可以帮助你进行动态创建与管理table views。它给我们提供了预定义cells（bool类型、文本、日期等等——请看下面的截图），但是你还可以创建自定义views，并与默认视图一同使用。 布局Layout1. MyLinearLayoutUI布局 2. CHTCollectionViewWaterfallLayout 🔥瀑布流layout 3. LXReorderableCollectionViewFlowLayoutiOS 实现多种分类 添加删除排序功能 star 1600+ 轮播1. SDCycleScrollView轮播 文件1. HYFileManager简单实用的iOS文件工具类 其它1. SloppySwiper手势返回 调试工具类1. FLEX是Flipboard开源的一系列在应用中调试的工具集 2. KMCGeigerCounter动画帧速计算类库 3. MMPlaceHolderapp内显示UI尺寸 4. MLeaksFinder内存泄露检测，微信读书出品成员出品 5. iRate 🔥App Store中获得更多评论的最佳方式 6. specta自动测试 ❋完整的项目开源代码❋1.Coding-iOS Coding_iOS客户端 ❋Swift开源代码❋网络1. Alamofire 🔥Alamofire是AFNetworking的小弟。更年轻更时尚|19000+ 颜色Color &amp; 素材1. Chameleon 🔥一个iOS的色彩框架。它运用现代化flat color将UIColor扩展地非常美观。我们还可以通过它运用自定义颜色创建调色板(OC&amp;sWIFT) AlertView &amp; ActionSheet1.PMAlertController自定义alertview|1000+ 2.TBActionSheet自定义ActionSheet |430+ 自动布局1. SnapKit 🔥swift自动布局 ☆7600+ 引导页 &amp; 启动页1. Onboard 🔥引导页(oc &amp; swift) 动画1. Spring 🔥iOS动画 ☆8800+ 键盘1. IQKeyboardManager解决键盘在遮挡(OC &amp; sSwift) Json1. SwiftyJSONSwift下JSON解析 ☆11400+ 其它1. PermissionScope是智能 iOS 用户权限 UI 和统一 API，可以智能的处理用户权限请求|2900+ 2. SwiftyDrop轻量、易用的小清新弹出列表及信息提示组件|400 3. KeychainAccess钥匙串管理|2000+ 工具1.Quickswift自动测试|5200+ 其它资源：iOS开发常用三方库、插件、知名博客等等]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>iOS,开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView-Auto-Layout-(iOS 8+)]]></title>
    <url>%2F2017%2F04%2F07%2F%5B%E8%AF%91%5DUITableView-Auto-Layout-(iOS-8%2B)%2F</url>
    <content type="text"><![CDATA[翻译自stack overflow的一个回答，对于iOS自动布局很有用处。翻译水平有限，且现在公司的app都是iOS 8+，所以只翻译了iOS 8+的部分。如有错误，欢迎指正！谢谢！ 概念描述无论你是哪个iOS开发版本，下面前2个步骤都适用。 设置 &amp; 添加约束 content-hugging and compression-resistance 以下简称CHCR；固有内容尺寸：intrinsic content size； 在你的UITableViewCell子类中，添加约束使cell的subviews的边缘固定到cell的contentView的边缘（最重要的是顶部(top)和底部(bottom)边缘）。注意：不要把subviews固定到cell自身；只能添加到cell的 contentView！通过确保CHCR在每个subview的垂直方向不被你添加的更高优先级约束重写，来让这些subviews的固有内容尺寸驱动表单元的内容视图高度（嘿？点击这里）。 Remember, the idea is to have the cell’s subviews connected vertically to the cell’s content view so that they can “exert pressure” and make the content view expand to fit them.使用一个例子，带有几个子视图的cell，这里有张直观的插图上面有一些（不是全部）你好像需要的约束： 想象一下，随着更多文本被添加到在上面例子cell中的多行label，它将要垂直增长以适应文本，这将有效地强制cell增长高度（当然，为了正确地工作，你需要得到约束！）。 获取正确的约束绝对是自动布局获取动态cell高度最难且最重要的一部分。如果你在这里犯了错，它将阻止你的一切工作，所以抓紧时间！我建议在代码中设置你的约束，因为你确切知道哪些约束被添加到哪里，并且当事情出错时调试起来容易得多.在代码中添加约束和IB一样简单并且当你使用一个神奇的开放源码API的时候回更强大–这里就有一个我专门设计和维护和使用的：https://github.com/smileyborg/PureLayout. 如果你在代码中添加约束，你应该在UITableViewCell 子类updateConstraints方法中执行一次添加。注意updateConstraints可能会不止调用一次，所以为了避免添加同样的约束多次，可以用一个bool值比如didSetupConstraints来检查包含的约束只添加一次（在约束添加之后设置为YES）。另一方面，如果你又代码要更新已存在的约束（比如调整constant属性相同的约束），将更新约束的代码发在updateConstraints中但是在didSetupConstraints的检查之外，这样更新的代码就可以在每次调用的时候执行了。 Determine Unique Table View Cell Reuse Identifiers对于在cell中的每一组唯一约束，请使用唯一的cell reuse identifier。换句话说，如果你的单元格有多个唯一的布局，每个独特的布局应该得到它自己的重用标识符（当你的cell发生变化有不同数量的子视图或是以一种独特的方式布置子视图时，你需要使用一个新的reuse identifier）。 比如，例如，如果你在每个单元格中显示一个电子邮件消息，你可能有4个独特的布局：只有subject的消息；带subject和一个body的消息；带subject和照片附件的消息；带subject，body和照片附件的消息。每种布局都有完全不同的约束来实现它，所以一旦cell被初始化并且这些cell 类型之一添加了约束，cell就需要为指定的cell type获取一个唯一的reuse identifier。这意味着当你复用cell出列时，为这个cell type的约束已经被添加并且准备执行了。 注意，由于固有内容尺寸的差异，具有相同约束（类型）的单元格可能仍有不同的高度！不要因为不同的内容尺寸混淆根本不同的布局（不同的约束）和不同的算出来的视图frame。 不要将具有完全不同约束集（sets of constraints）的cell添加到同一重用池（ reuse pool）中（比如使用相同的reuse identifier）并且在后面的队列中尝试删除旧约束从头开始添加新约束。内部自动布局引擎不是设计来处理大规模的约束变化，你会看到大量的性能问题。 Enable Row Height Estimation在iOS 8中，苹果已经把许多在iOS 8之前需要由你完成的工作内部化实现了。为了让 self-sizing cell 机制工作，你必须首先设置tableview的rowHeight属性值为UITableViewAutomaticDimension.然后，你仅需要通过设置tableview的estimatedRowHeight属性值为一个非零值就可以开启行高估算（Row Height Estimation）。例如： 12self.tableView.rowHeight = UITableViewAutomaticDimension;self.tableView.estimatedRowHeight = 44.0; // set to whatever your &quot;average&quot; cell height is 这个所做的是给tableview还未出现在屏幕上的cell的豪赌提供一个临时估算或占位。然后，当这些cell要滚动到屏幕上时实际的行高将会被计算。为了确定每行的实际高度，tableview自动询问每个cell它的contentview基于已知的content view固定宽度和你添加到cell的content view 及 subviews的自动布局约束所需要的高度。一旦cell的真实高度确定，估算高度就会更新为真实高度（任何tableview的contentSize/contentOffset调整需要你来做）。 一般来讲，你提供的估算并不需要非常准确–它只是用来合适的排列在tableview中的scroll indicator，在滚动屏幕上的单元格时，表视图可以很好地调整滚动指示器的估计值。你应该将表视图（在viewDidLoad或类似方法中）中的estimatedRowHeight属性设置为一个常量值，即“平均”行高。只有当你的行高有极大的可变性（例如相差一个数量级），你注意到滚动指示器“跳跃”，如果你麻烦执行tableView：estimatedHeightForRowAtIndexPath：做最小的计算，为每行返回更准确的估算值。 iOS的8示例项目 -需要iOS 8]]></content>
      <categories>
        <category>自动布局</category>
      </categories>
      <tags>
        <tag>iOS,autolayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Auto-Layout-Guide》笔记]]></title>
    <url>%2F2017%2F04%2F07%2F%E3%80%8AAuto-Layout-Guide%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[概念约束优先级所有约束都有1-1000的优先级。优先级为1000的约束是必须的。其它约束都是可选的。 注意：不要强迫使用所有1000个优先级值。实际上，优先级通常聚集在系统定义的低（250），中（500），高（750）和必须（1000）周围。可能需要让约束的优先级比这些值高或低1-2点，来帮助阻止绑定（teis）。如果优先级远远超出这些值，可能需要重新检查布局逻辑。 固有内容尺寸(Intrinsic Content Size)有些视图根据当前给定的内容有个自然的尺寸。这个尺寸被称为固有内容尺寸(Intrinsic Content Size)。 不是所有视图都有固有内容尺寸。对于有固有内容尺寸的视图，它可以定义视图的高度，宽度或者两者都定义。下面的表格列出了一些例子（这里只标注iOS的，mac OS已删除）。 视图 固有内容尺寸 UIView 没有固有内容尺寸 UISlider 只定义了宽度。 UILabel,UIbutton,UISwitch,UITextField 同时定义了宽度和高度。 UITextView,UIImageView 固有内容尺寸可以改变。 Content hugging &amp; Compression resistance自动布局使用了一对约束来呈现一个视图的每个维度。content hugging向内抱紧视图，使紧贴内容（简称抱紧我）。压缩阻力（compression resistance）向外推视图，使其不剪辑内容（简称别挤我）。 Content hugging优先级越高，抱的越紧；compression resistance优先级越高，压缩阻力越大，内容越不容易被剪辑。 下面举两个例子说明一下： 例1（Content hugging）通常会有这样一个功能，左侧label，提示输入名字，右侧是一个textfield，用于输入名字，如下图所示： 这时候我们希望name足够小，能显示name足以，textfield则尽量拉伸。这时候只需要name的Content hugging属性优先级大于textfield就可以了。 例2（compression resistance）给一个label添加宽度为80的约束，如果label的文字超过80，那么显示就会这样： 因为compression resistance默认优先级为750，而高宽这些数据的优先级默认是required（即1000）。所以我们只要将宽度的约束优先级修改一下，比750小即可，比如749.这样修改后，效果如下： 这样应该就能很好理解两个属性的意义了。 常见关系优先级： 属性或关系 优先级 equal 1000 greater-than-or-equal 1000 less-than-or-equal 1000 Content hugging 250 Compression resistance 750 工具Align工具Align工具可以快速对齐布局中的项。选择想要对齐的项，然后单击Align工具。界面生成器显示一个弹出框视图，其中包括一些可能的对齐选项。 Pin工具Pin工具可以快速定义视图相对于它邻居的位置，或者快速定义视图的尺寸。选择想要固定(pin)位置或尺寸的项，然后点击Pin工具。界面生成器显示一个弹出框视图，其中包括一些选项。 弹出框顶部区域可以固定选中项的开头，顶部，结尾或底部边缘到它最近的邻居。关联的数字表示画布中两个项之间的当前间隔。可以输入自定义的间隔，或者点击三角形，设置它被约束到哪个视图，或者选择标准间隔。Constrain to margins复选框决定约束使用父视图的页边留白（margin）还是它的边缘（edge）。 Resolve Auto Layout Issues工具Resolve Auto Layout Issues工具提供了一些选项用来修复常见的自动布局问题。菜单的上半部分只影响当前选中的视图。下半部分选项影响场景中所有视图。 可以使用这个工具更新视图的框架（frame），基于当前的约束，或者根据视图在画布中的当前位置更新约束。还可以添加缺失的约束，清理约束，或者重置视图为界面生成器推荐的约束。 调试技巧在自动布局过程中，出现错误是经常的事情，自动布局中的错误主要分为三个类型： 不可满足的（unsatisfiable）布局。布局没有有效的解。更多信息请参考不可满足的布局。 有歧义的布局。你的布局有两个或多个可能的解。更多信息请参考有歧义的布局。 逻辑错误。布局逻辑中存在bug。更多信息请参考逻辑错误。 调试方法：查看控制台的打印信息，有时候打印的信息比较多，不方便看，添加标识符，是一个很好的方法。 高级自动布局推迟的布局过程自动布局安排一个布局过程在不久的将来取代直接更新受影响的view的frame。该推迟的过程更新布局的约束，然后计算视图层次结构中所有视图的frame。 可以通过调用setNeedsLayout方法或者setNeedsUpdateConstraints方法，调度自己的推迟的布局过程。 推迟的布局过程实际涉及视图层级结构的两个过程：1.更新过程根据需要更新约束。2.布局过程根据需要重新定位视图的frame。 更新过程系统遍历视图层级结构，并在所有视图控制器上调用updateViewConstraints方法，在所有视图上调用updateConstraints方法。你可以覆写这些方法，来优化约束的改变（查看批量改变）。 布局过程系统再次遍历视图层级结构，并在所有视图控制器上调用viewWillLayoutSubviews方法，在所有视图上调用layoutSubviews。默认情况下，layoutSubviews方法使用自动布局引擎计算的矩形更新每个子视图的frame。你可以覆写这些方法来修改布局（查看自定义布局）。 批量改变影响变化发生后，立即更新约束几乎总是更干净和容易。推迟这些改变到一个之后的方法会让代码复杂，更难理解。 然而，有些时候你可能基于性能原因，希望批量修改。只有在就地改变约束太慢，或者当视图做了很多多余的改变时，才应该这么做。 要想批量改变，在持有约束的视图上调用setNeedsUpdateConstraints方法，而不是直接做出改变。然后，覆写视图的updateConstraints方法，来修改受影响的约束。 提示:你的updateConstraints实现必须尽可能高效。不要禁用所有约束，然后启用你需要的。相反，你的应用程序必须有些方式来追踪你的约束，并在每个更新过程中验证它们。只有变化的项需要改变。在每一个更新过程中，你必须确保应用程序的当前状态有合适的约束。 总是在你实现的updateConstraints方法的最后一步调用父类的实现。 不要在你的updateConstraints方法中调用setNeedsUpdateConstraints。调用setNeedsUpdateConstraints调度另一个更新过程，创建了一个反馈回路（feedback loop）。 参考：Auto Layout Guide自动布局指南]]></content>
      <categories>
        <category>自动布局</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[详解自动布局(Masonry)实现九宫格]]></title>
    <url>%2F2017%2F04%2F07%2F%E8%AF%A6%E8%A7%A3%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%EF%BC%88Masonry%EF%BC%89%E5%AE%9E%E7%8E%B0%E4%B9%9D%E5%AE%AB%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[以前写TimeLine中照片九宫格布局是直接计算frame，今天想用自动布局实现。 九宫格布局使用自动布局，首先就必须知道给出了哪些条件。一般在TimeLine中照片九宫格布局给出的已知条件为： 每个单元的宽cellWidth； 每个单元的高cellHeight； 每行有几个单元numPerRow； 总共单元个数totalNum； 每个单元与边界间距viewPadding； 每个单元之间的间距viewPaddingCell。 图 1是一个九宫格，黄色区域为父视图，由已知条件可知，它的大小是由里面的单元格布局决定的，所以，只要固定住里面的单元格，父视图就会自动固定住。下面我们来添加约束：1.所有单元格添加高度（height）和宽度（width）约束，如图 2所示， 2.第一行相对父视图，添加top约束，如图三中紫色箭头所示， 3.非第一行添加对上一行单元的top约束，如图四红色箭头所示， 4.第一列添加对父视图的left约束，如图五墨绿色箭头所示 5.非第一列添加对上一个view的left约束，如图6深蓝色箭头所示 这时候你会发现所有单元格都固定了，但是父视图的大小却不能固定，因为还不能得出父视图的宽和高 6.右上角（第一行&amp;最后一列）添加对父视图right约束，如图7所示，2号单元格右侧绿色箭头 7.左下角（最后一行&amp;第一列）添加对父视图的bottom约束，如图8所示，6号单元格底部紫色箭头 talk is cheap show me the code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** 九宫格布局（不限于九宫格，可以是N个格子），每个格子给定高（cellHeight）宽（cellWidth）， 每行格子数量（numPerRow），格子总数量（totalNum），格子与边界距离（viewPadding），格 子之间的距离（viewPaddingCell）。 @param cellWidth 格子宽度 @param cellHeight 格子高度 @param numPerRow 每行格子数量 @param totalNum 格子总数量 @param viewPadding 格子与边界距离 @param viewPaddingCell 格子之间的距离 @param superView 父视图 */- (void)gridWithCellWidth:(CGFloat)cellWidth cellHeight:(CGFloat)cellHeight numPerRow:(NSInteger)numPerRow totalNum:(NSInteger)totalNum viewPadding:(CGFloat)viewPadding viewPaddingCell:(CGFloat)viewPaddingCell superView:(UIView *)superView&#123; __block UILabel *lastView = nil;// 创建一个空view 代表上一个view __block UILabel *lastRowView;// 创建一个空view 代表上一行view __block NSInteger lastRowNo = 0;//上一行的行号 NSMutableArray *cells = [[NSMutableArray alloc] init]; for (int i = 0; i &lt; totalNum; i++) &#123; UILabel *aLabel = [UILabel new]; aLabel.text = [NSString stringWithFormat:@&quot;%d&quot;,i]; [superView addSubview:aLabel]; aLabel.backgroundColor = [UIColor colorWithHue:(arc4random() % 256 / 256.0 ) saturation:( arc4random() % 128 / 256.0 ) + 0.5 brightness:( arc4random() % 128 / 256.0 ) + 0.5 alpha:1.0]; [cells addObject:aLabel]; &#125; // 循环创建view for (int i = 0; i &lt; cells.count; i++) &#123; UILabel *lb = cells[i]; BOOL isFirstRow = [self isFirstRowWithIndex:i numOfRow:numPerRow]; BOOL isFirstCol = [self isFirstColumnWithIndex:i numOfRow:numPerRow]; BOOL isLastCol = [self isLastColumnWithIndex:i numOfRow:numPerRow totalNum:totalNum]; BOOL isLastRow = [self isLastRowWithIndex:i numOfRow:numPerRow totalNum:totalNum]; NSInteger curRowNo = i/numPerRow; if (curRowNo != lastRowNo) &#123;//如果当前行与上一个view行不等，说明换行了 lastRowView = lastView; lastRowNo = curRowNo; &#125; // 添加约束 [lb mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.equalTo(@(cellWidth)); make.height.equalTo(@(cellHeight)); if (isFirstRow) &#123; make.top.equalTo(superView.mas_top).with.offset(viewPadding); &#125; else &#123; if (lastRowView) &#123; make.top.equalTo(lastRowView.mas_bottom).with.offset(viewPaddingCell); &#125; &#125; if (isFirstCol) &#123; make.left.equalTo(superView.mas_left).with.offset(viewPadding); &#125; else &#123; if (lastView) &#123; make.left.equalTo(lastView.mas_right).with.offset(viewPaddingCell); &#125; &#125; if (isFirstRow &amp;&amp; isLastCol) &#123; make.right.equalTo(superView.mas_right).with.offset(-viewPadding); &#125; if (isLastRow &amp;&amp; isFirstCol) &#123; make.bottom.equalTo(superView.mas_bottom).with.offset(-viewPadding); &#125; &#125;]; // 每次循环结束 此次的View为下次约束的基准 lastView = lb; &#125;&#125; 代码中有一些判断，比如是否为第一行， 12345678910111213141516/** 是否第一行 @param index 当前下标 @param numOfRow 每行个数 @return YES OR NO */- (BOOL)isFirstRowWithIndex:(NSInteger)index numOfRow:(NSInteger)numOfRow&#123; if (numOfRow != 0) &#123; return index/numOfRow == 0; &#125; return NO;&#125; 是否为第一列，12345678910111213141516/** 是否第一列 @param index 当前下标 @param numOfRow 每行个数 @return YES OR NO */- (BOOL)isFirstColumnWithIndex:(NSInteger)index numOfRow:(NSInteger)numOfRow&#123; if (numOfRow != 0) &#123; return index%numOfRow == 0; &#125; return NO;&#125; 是否为最后一行，123456789101112131415161718/** 是否最后一行 @param index 当前下标 @param numOfRow 每行个数 @return YES OR NO */- (BOOL)isLastRowWithIndex:(NSInteger)index numOfRow:(NSInteger)numOfRow totalNum:(NSInteger)totalNum&#123; NSInteger totalRow = ceil(totalNum/((CGFloat)numOfRow));//总行数 if (numOfRow != 0) &#123; return index/numOfRow == totalRow - 1; &#125; return NO;&#125; 是否为最后一列 1234567891011121314151617181920/** 是否最后一列 @param index 当前下标 @param numOfRow 每行个数 @return YES OR NO */- (BOOL)isLastColumnWithIndex:(NSInteger)index numOfRow:(NSInteger)numOfRow totalNum:(NSInteger)totalNum&#123; if (numOfRow != 0) &#123; if (totalNum &lt; numOfRow) &#123;//总数小于每行最大个数时，如果index是最后一个，那么也是最后一列 return index == totalNum-1; &#125; return index%numOfRow == numOfRow - 1; &#125; return NO;&#125; 注意：这里有个地方要注意，当你的单元格总数（totalNum ）小于每行个数 （numOfRow），比如总共有2个单元格，每行排三个，那么最后一个即为最后一列。 上面这四个判断在很多地方都可以用到，可以记下备用🙂。 然后是上一行的view判断也需要注意。 其实这不单单只是九宫格布局，N个单元格布局也是可以的，感兴趣的小伙胖可以自行测试（好吧，估计你从我写的方法名已经看出来了，每行个数和总个数我都没有写死😂）。 另一种九宫格这里的九宫格布局是子视图固定，而父视图由子视图决定，还有另一种情况：父视图高宽固定，子视图与父视图边界距离给定，子视图间距给定。知道怎么布局吗？可以先思考一下。||||||好吧，揭晓答案：只要按照第一种九宫格前5个步骤来添加约束即可，去掉最后两步。 总结一开始我只是想布局一个九宫格，但是后来又想，如果需求扩展到了N个单元，该如何实现呢，我的办法是从九宫格开始，由小及大来推导，然后就是要知道自动布局需要添加哪些约束，能够完整的固定视图，不能多，也不要少，这是很重要的。]]></content>
      <categories>
        <category>自动布局</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
